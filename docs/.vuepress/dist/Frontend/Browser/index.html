<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器 | Mintnoii&#39;s Notes</title>
    <meta name="description" content=" 📖 🤔 👨🏻‍💻 ">
    <link rel="icon" href="/img/favorite.ico">
    
    <link rel="preload" href="/assets/css/0.styles.ceb91a1a.css" as="style"><link rel="preload" href="/assets/js/app.931542fe.js" as="script"><link rel="preload" href="/assets/js/2.0fac7938.js" as="script"><link rel="preload" href="/assets/js/5.96e50475.js" as="script"><link rel="prefetch" href="/assets/js/10.fbe814e3.js"><link rel="prefetch" href="/assets/js/11.937b3f81.js"><link rel="prefetch" href="/assets/js/12.c5d22a71.js"><link rel="prefetch" href="/assets/js/13.4ffef7d1.js"><link rel="prefetch" href="/assets/js/14.dfba7b0d.js"><link rel="prefetch" href="/assets/js/15.8d3ada72.js"><link rel="prefetch" href="/assets/js/16.b36df3ea.js"><link rel="prefetch" href="/assets/js/17.88178c37.js"><link rel="prefetch" href="/assets/js/18.02d9dd67.js"><link rel="prefetch" href="/assets/js/19.b3a4ec1d.js"><link rel="prefetch" href="/assets/js/20.70c20c38.js"><link rel="prefetch" href="/assets/js/21.14fc5229.js"><link rel="prefetch" href="/assets/js/3.17b694f5.js"><link rel="prefetch" href="/assets/js/4.c99d3f5c.js"><link rel="prefetch" href="/assets/js/6.af14ba40.js"><link rel="prefetch" href="/assets/js/7.1146c45d.js"><link rel="prefetch" href="/assets/js/8.0dabff96.js"><link rel="prefetch" href="/assets/js/9.83b0e3ce.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ceb91a1a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Mintnoii's Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="FE" class="dropdown-title"><span class="title">FE</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Basic</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/Frontend/HTML/" class="nav-link">HTML</a></li><li class="dropdown-subitem"><a href="/Frontend/CSS/" class="nav-link">CSS</a></li><li class="dropdown-subitem"><a href="/Frontend/JavaScript/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/Frontend/Browser/" class="nav-link router-link-exact-active router-link-active">Browser</a></li></ul></li><li class="dropdown-item"><h4>Engineering</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/Frontend/Webpack/" class="nav-link">Webpack</a></li><li class="dropdown-subitem"><a href="/Frontend/Git/" class="nav-link">Git</a></li></ul></li><li class="dropdown-item"><h4>Framework</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/Frontend/Vue/" class="nav-link">Vue</a></li><li class="dropdown-subitem"><a href="/Frontend/React/" class="nav-link">React</a></li><li class="dropdown-subitem"><a href="/Frontend/ReactFiber/" class="nav-link">React Fiber</a></li></ul></li><li class="dropdown-item"><h4>Security</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/Frontend/Security/" class="nav-link">Security</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="CS" class="dropdown-title"><span class="title">CS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Net protocol</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/CS/HTTP/" class="nav-link">HTTP</a></li><li class="dropdown-subitem"><a href="/CS/TCP/" class="nav-link">TCP</a></li></ul></li></ul></div></div><div class="nav-item"><a href="https://www.notion.so/Hi-here-0a4a01ce46dc475a9318075eda4ad3b0" target="_blank" rel="noopener noreferrer" class="nav-link external">
  About
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/W-Qing/Notes" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="FE" class="dropdown-title"><span class="title">FE</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Basic</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/Frontend/HTML/" class="nav-link">HTML</a></li><li class="dropdown-subitem"><a href="/Frontend/CSS/" class="nav-link">CSS</a></li><li class="dropdown-subitem"><a href="/Frontend/JavaScript/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/Frontend/Browser/" class="nav-link router-link-exact-active router-link-active">Browser</a></li></ul></li><li class="dropdown-item"><h4>Engineering</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/Frontend/Webpack/" class="nav-link">Webpack</a></li><li class="dropdown-subitem"><a href="/Frontend/Git/" class="nav-link">Git</a></li></ul></li><li class="dropdown-item"><h4>Framework</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/Frontend/Vue/" class="nav-link">Vue</a></li><li class="dropdown-subitem"><a href="/Frontend/React/" class="nav-link">React</a></li><li class="dropdown-subitem"><a href="/Frontend/ReactFiber/" class="nav-link">React Fiber</a></li></ul></li><li class="dropdown-item"><h4>Security</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/Frontend/Security/" class="nav-link">Security</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="CS" class="dropdown-title"><span class="title">CS</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Net protocol</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/CS/HTTP/" class="nav-link">HTTP</a></li><li class="dropdown-subitem"><a href="/CS/TCP/" class="nav-link">TCP</a></li></ul></li></ul></div></div><div class="nav-item"><a href="https://www.notion.so/Hi-here-0a4a01ce46dc475a9318075eda4ad3b0" target="_blank" rel="noopener noreferrer" class="nav-link external">
  About
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/W-Qing/Notes" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Frontend/HTML/" class="sidebar-link">HTML</a></li><li><a href="/Frontend/CSS/" class="sidebar-link">CSS</a></li><li><a href="/Frontend/JavaScript/" class="sidebar-link">JavaScript</a></li><li><a href="/Frontend/Browser/" class="active sidebar-link">浏览器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Frontend/Browser/#组成部分" class="sidebar-link">组成部分</a></li><li class="sidebar-sub-header"><a href="/Frontend/Browser/#常见内核" class="sidebar-link">常见内核</a></li><li class="sidebar-sub-header"><a href="/Frontend/Browser/#渲染机制" class="sidebar-link">渲染机制</a></li><li class="sidebar-sub-header"><a href="/Frontend/Browser/#event-loop-🌟" class="sidebar-link">Event Loop 🌟</a></li><li class="sidebar-sub-header"><a href="/Frontend/Browser/#垃圾回收机制" class="sidebar-link">垃圾回收机制</a></li><li class="sidebar-sub-header"><a href="/Frontend/Browser/#事件机制" class="sidebar-link">事件机制</a></li><li class="sidebar-sub-header"><a href="/Frontend/Browser/#bom-操作" class="sidebar-link">BOM 操作</a></li><li class="sidebar-sub-header"><a href="/Frontend/Browser/#ajax-与-跨域" class="sidebar-link">Ajax 与 跨域</a></li><li class="sidebar-sub-header"><a href="/Frontend/Browser/#存储" class="sidebar-link">存储</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>安全</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="浏览器"><a href="#浏览器" class="header-anchor">#</a> 浏览器</h1> <h2 id="组成部分"><a href="#组成部分" class="header-anchor">#</a> 组成部分</h2> <ol><li><strong>用户界面</strong> - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的你请求的页面外，其他显示的各个部分都属于用户界面。</li> <li><strong>浏览器引擎</strong> - 在用户界面和渲染引擎之间传送指令。</li> <li><strong>渲染引擎</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li> <li><strong>网络</strong> - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li> <li><strong>用户界面后端</strong> - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li> <li><strong>JavaScript 解释器</strong>。用于解析和执行 JavaScript 代码。</li> <li><strong>数据存储</strong>。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li></ol> <p><img src="/assets/img/partOfBrowser.7ba7cd1c.png" alt="img"></p> <blockquote><p>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个渲染引擎实例。每个标签页都是一个独立的进程。</p></blockquote> <h2 id="常见内核"><a href="#常见内核" class="header-anchor">#</a> 常见内核</h2> <p>浏览器的内核是指支持浏览器运行的最核心的程序，分为两个部分：一是渲染引擎，另一个是 JS 引擎。</p> <p>渲染引擎在不同的浏览器中也不是都相同的，目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。</p> <table><thead><tr><th style="text-align:center;">浏览器/RunTime</th> <th style="text-align:center;">内核（渲染引擎）</th> <th style="text-align:center;">JavaScript 引擎</th></tr></thead> <tbody><tr><td style="text-align:center;">Chrome</td> <td style="text-align:center;">Blink（28~） Webkit（Chrome 27）</td> <td style="text-align:center;">V8</td></tr> <tr><td style="text-align:center;">FireFox</td> <td style="text-align:center;">Gecko</td> <td style="text-align:center;">SpiderMonkey</td></tr> <tr><td style="text-align:center;">Safari</td> <td style="text-align:center;">Webkit</td> <td style="text-align:center;">JavaScriptCore</td></tr> <tr><td style="text-align:center;">Edge</td> <td style="text-align:center;">EdgeHTML</td> <td style="text-align:center;">Chakra(for JavaScript)</td></tr> <tr><td style="text-align:center;">IE</td> <td style="text-align:center;">Trident</td> <td style="text-align:center;">Chakra(for JScript)</td></tr> <tr><td style="text-align:center;">PhantomJS</td> <td style="text-align:center;">Webkit</td> <td style="text-align:center;">JavaScriptCore</td></tr> <tr><td style="text-align:center;">Node.js</td> <td style="text-align:center;">-</td> <td style="text-align:center;">V8</td></tr></tbody></table> <h2 id="渲染机制"><a href="#渲染机制" class="header-anchor">#</a> 渲染机制</h2> <p>先了解下浏览器请求加载资源的过程，然后才能更好的理解浏览器的渲染机制。</p> <p><strong>浏览器请求加载一个资源的主要过程：</strong></p> <ul><li>浏览器根据 DNS 服务器得到域名的 IP 地址</li> <li>向这个 IP 的服务器发送 http 请求</li> <li>服务器收到请求，处理并返回 http 请求</li> <li>浏览器得到返回内容</li></ul> <p>浏览器得到服务器返回的内容后，接下来就是渲染过程。</p> <p><strong>浏览器渲染页面的过程：</strong></p> <ol><li>解析 HTML 结构生成 DOM 树形结构—<strong>DOM Tree</strong></li> <li>解析 CSS，生成 CSS 规则树—<strong>CSSOM Tree</strong></li> <li>解析完成后，浏览器引擎会通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSSOM Tree，组合形成渲染树—<strong>Render Tree</strong></li> <li>根据渲染树来进行布局—<strong>Layout</strong> （计算出各个节点在页面中的确切位置和大小，所有相对测量值都将转换为屏幕上的绝对像素）</li> <li>布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素，即绘制页面—<strong>reflow/repaint</strong></li></ol> <blockquote><ul><li>遇到<code>&lt;script&gt;</code> 时，会执行并阻塞渲染，因为 JS 有可能改变 DOM 树结构 ( GUI 渲染线程与 JS 引擎线程互斥 )</li> <li>而 img、 video 则是异步加载，不会阻塞渲染</li> <li>通常情况下 DOM 和 CSSOM 是并行构建的，但是当浏览器遇到一个不带 defer 或 async 属性的 script 标签时，DOM 构建将暂停，如果此时又恰巧浏览器尚未完成 CSSOM 的下载和构建，由于 JavaScript 可以修改 CSSOM，所以需要等 CSSOM 构建完毕后再执行 JS，最后才重新进行 DOM 构建</li></ul></blockquote> <p><strong>浏览器的重排与重绘</strong></p> <p>区别：</p> <ul><li>重排：部分渲染树（或者整个渲染树）需要重新分析，并且节点尺寸需要重新计算，表现为重新生成布局，重新排列元素</li> <li>重绘：节点的几何属性发生改变或者样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新，表现为某些元素的外观被改变</li></ul> <p>单单改变元素的外观，肯定不会引起网页重新生成布局，但当浏览器完成重排之后，将会重新绘制受到此次重排影响的部分。即：『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。</p> <p>重排和重绘代价是高昂的，如果处理不好，它们会使 UI 展示变得迟缓，破坏用户体验。</p> <p>虽然任何改变用来构建渲染树的信息都会导致一次重排或重绘，但可以通过几种方法尽量减少重排或重绘：</p> <ol><li>通过改变 class 的方式来集中改变样式</li> <li>通过 createDocumentFragment 创建一个游离于 DOM 树之外的节点，然后在此节点上批量操作，最后插入 DOM 树中，因此只触发一次重排</li> <li>使用 CSS 的 will-change 属性将元素提升为合成层</li></ol> <blockquote><p>关于合成层的详解请移步 <a href="https://fed.taobao.org/blog/2016/04/26/performance-composite/" target="_blank" rel="noopener noreferrer">无线性能优化：Composite<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <p>两者相比之下显然重排的性能影响更大，在两者无法避免的情况下应优先选择代价更小的重绘。</p> <p><strong>Load 和 DOMContentLoaded 区别：</strong></p> <p>window.onload  事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。</p> <p>DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。</p> <div class="language-js extra-class"><pre class="language-js"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'load'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 页面的全部资源加载完才会执行，包括图片、视频等</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

document<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'DOMContentLoaded'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// DOM 渲染完即可执行，此时图片、视频可能还没有加载完</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>推荐阅读：</p> <ul><li><a href="https://github.com/ljianshu/Blog/issues/51" target="_blank" rel="noopener noreferrer">深入浅出浏览器渲染原理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/berwin/Blog/issues/29" target="_blank" rel="noopener noreferrer">关键渲染路径<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 👏</li> <li><a href="https://juejin.im/post/5e143104e51d45414a4715f7#heading-28" target="_blank" rel="noopener noreferrer">从 8 道面试题看浏览器渲染过程与性能优化<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank" rel="noopener noreferrer">How Browsers work <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></blockquote> <h2 id="event-loop-🌟"><a href="#event-loop-🌟" class="header-anchor">#</a> Event Loop 🌟</h2> <h3 id="栈、队列的基本概念"><a href="#栈、队列的基本概念" class="header-anchor">#</a> 栈、队列的基本概念</h3> <p><strong>栈（Stack）</strong></p> <ul><li>栈在计算机科学中是限定仅在<strong>表尾</strong>进行<strong>插入</strong>或<strong>删除</strong>操作的线性表。</li> <li>栈是一种数据结构，它按照<strong>后进先出</strong>的原则存储数据，<strong>先进入</strong>的数据被压入<strong>栈底</strong>，<strong>最后的数据</strong>在<strong>栈顶</strong>，需要读数据的时候从<strong>栈顶</strong>开始<strong>弹出数据</strong>。（<code>LIFO: last in first out</code>）</li> <li>栈是只能在<strong>某一端插入</strong>和<strong>删除</strong>的<strong>特殊线性表</strong>。</li></ul> <p><strong>队列（Queue）</strong></p> <ul><li>特殊之处在于它只允许在表的前端（<code>front</code>）进行<strong>删除</strong>操作，而在表的后端（<code>rear</code>）进行<strong>插入</strong>操作，和<strong>栈</strong>一样，<strong>队列</strong>是一种操作受限制的线性表。</li> <li>进行<strong>插入</strong>操作的端称为<strong>队尾</strong>，进行<strong>删除</strong>操作的端称为<strong>队头</strong>。 队列中没有元素时，称为<strong>空队列</strong>。</li> <li><strong>队列</strong>的数据元素又称为<strong>队列元素</strong>。在队列中插入一个队列元素称为<strong>入队</strong>，从<strong>队列</strong>中<strong>删除</strong>一个队列元素称为<strong>出队</strong>。</li> <li>因为队列<strong>只允许</strong>在一端<strong>插入</strong>，在另一端<strong>删除</strong>，所以只有<strong>最早</strong>进入<strong>队列</strong>的元素<strong>才能最先从队列中</strong>删除，故队列又称为<strong>先进先出</strong>。（<code>FIFO: first in first out</code>）</li></ul> <h3 id="宏认为与微任务"><a href="#宏认为与微任务" class="header-anchor">#</a> 宏认为与微任务</h3> <p>在<code>JavaScript</code>中，任务被分为两种，一种宏任务（<code>MacroTask</code>）也叫<code>Task</code>，一种叫微任务（<code>MicroTask</code>），也叫<code>Jobs</code>。</p> <p><strong>MacroTask（宏任务）</strong></p> <p>在 JavaScript 中，大部分的任务都是在主线程上执行，为了让这些事件有条不紊地进行，JS 引擎需要对它们的执行顺序做一定的安排，V8 其实采用的是<code>队列</code>的方式来存储这些同步任务， 即先进来的先执行。</p> <ul><li>script 全部代码，即 js 脚本执行</li> <li>setTimeout、setInterval、setImmediate（只有 IE10 支持）</li> <li>I/O 用户交互、网络请求、文件读写完成事件等</li> <li>UI rendering 渲染事件</li></ul> <p><strong>MicroTask（微任务）</strong></p> <p>如果异步回调也像宏任务一样进行队列的入队操作，那么执行这些回调的时机就是在前面<code>所有的宏任务</code>完成之后（先进先出），倘若现在的任务队列非常长，那么异步回调迟迟得不到执行，会造成<code>应用卡顿</code>。</p> <p>为了规避这样的问题，V8 引入了<code>微任务</code>的解决方式。在每一个宏任务中定义一个<strong>微任务队列</strong>，当该宏任务执行完成，会检查其中的微任务队列，如果为空则直接执行下一个宏任务，如果不为空，则<code>依次执行微任务</code>，执行完成才去执行下一个宏任务。</p> <ul><li>Promise、fetch API</li> <li>Object.observe （废弃）</li> <li>MutationObserver</li> <li>process.nextTick（Node 独有）</li> <li>V8 的垃圾回收</li></ul> <p><strong>requestAnimationFrame</strong></p> <p><code>requestAnimationFrame</code>也属于异步执行的方法，但该方法既不属于宏任务，也不属于微任务。</p> <blockquote><p><code>window.requestAnimationFrame()</code> 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p></blockquote> <p>requestAnimationFrame 是 GUI 渲染之前执行，但在微服务之后，不过 requestAnimationFrame 不一定会在当前帧必须执行，由浏览器根据当前的策略自行决定在哪一帧执行。</p> <h3 id="浏览器端的-event-loop"><a href="#浏览器端的-event-loop" class="header-anchor">#</a> 浏览器端的 Event Loop</h3> <p><strong>Event Loop（事件循环）是指浏览器或<code>Node</code>的一种实现<code>javaScript</code>单线程运行时不会阻塞的一种机制（JS 运行机制）</strong>，也就是我们经常使用的<strong>异步</strong>的原理。</p> <p>众所周知 JS 是一门非阻塞的单线程语言，同一时间只能执行一个任务，即代码的执行是同步并且阻塞的。</p> <blockquote><ol><li>首先是历史原因，在创建 JS 这门语言时，多进程多线程的架构并不流行，硬件支持并不好。</li> <li>其次是因为多线程的复杂性，多线程操作需要加锁，编码的复杂性会增高。</li> <li>最主要的是，JS 就是为了和浏览器交互而诞生的，如果在多个线程中同时操作 DOM ，在不加锁的情况下，最终会导致 DOM 渲染的结果不可预期（一个线程中新加节点，另一个线程中删除节点）。</li></ol></blockquote> <blockquote><p>尽管 HTML5 中有 Web-Worker，但 JS 仍然是单线程的。一切 JavaScript 版的&quot;多线程&quot;都是用单线程模拟出来的。</p></blockquote> <p>只有一个主线程，那 javascript 是如何处理各种同步与异步函数的调用关系的？答案是——<strong>调用栈</strong>。</p> <p><img src="/assets/img/eventloop.796a8f79.jpg" alt="Event Loop"></p> <p>单线程的运行环境有且只有一个 <code>call-stack</code> 调用栈（执行栈），所有的任务都会被放到调用栈等待浏览器的主线程执行。</p> <p>调用栈采用的是后进先出 (LIFO) 的规则，当一个函数被执行的时候，它会被添加到栈的顶部（如果它的函数体内有其他函数，则将新的函数加到栈顶），当函数在调用栈内被执行完成后，就会从栈顶移出，直到栈内被清空。</p> <p>当调用栈执行完毕之后，就会在队列里面找任务，如果有微任务，就会先执行微任务，再去执行宏任务。</p> <p><strong>事件循环：</strong> 就是同步任务进入主线程，异步任务加入到任务队列中。等主线程的任务执行完就去执行任务队列中的任务，这个过程会不断重复。<strong>所有同步任务都在主线程上执行，形成一个执行栈。主线程之外，存在一个任务队列 (task queue), 异步任务有了运行结果会在任务队列之中放置一个任务。执行栈中的所有同步任务执行完毕后读取任务队列（先读取微任务、宏任务）不断重复上面的第三步。</strong></p> <blockquote><p>本质上来说 JS 中的异步还是同步行为</p></blockquote> <p>有点晕？看这里👉🏻<a href="https://www.bilibili.com/video/av74599059?t=960" target="_blank" rel="noopener noreferrer">到底什么是 Event Loop 呢？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>👀</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>
</code></pre></div><p>举个🌰，上面👆的代码中虽然 setTimeout 延时为 0，但它还是异步的。所以 setTimeout 还是会在 script end 之后打印。</p> <blockquote><p>In fact, HTML5 标准规定这个函数第二个参数不得小于 4 毫秒，不足会自动增加。</p></blockquote> <p>不同的任务源会被分配到不同的 Task 队列中。</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Promise'</span><span class="token punctuation">)</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>
<span class="token comment">// 			 1						2							3						4						5						6</span>
<span class="token comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span>
</code></pre></div><p>以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务，所以会有以上的打印。</p> <p>所以正确的一次 Event loop 顺序是这样的：</p> <ol><li>一开始整段脚本作为第一个<strong>宏任务</strong>执行 (main script)</li> <li>执行过程中同步代码 (1)(2)(3) 直接执行，<strong>宏任务</strong>进入宏任务队列，<strong>微任务</strong>进入微任务队列</li> <li>当前宏任务执行完出队，检查微任务队列，如果有则依次执行 (4)(5)，直到微任务队列为空</li> <li>必要的话，执行浏览器 UI 线程的渲染工作</li> <li>检查是否有 Web worker 任务，有则执行</li> <li>执行队首新的宏任务 (6)，回到 2，开始下一轮 Event loop，依此循环，直到宏任务和微任务队列都为空</li></ol> <p>通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中。</p> <blockquote><p>⚠️注意：Promise 的 executor 是一个同步函数，即非异步，立即执行的一个函数，因此它 (2) 应该是和当前的任务一起执行的。而 Promise 的链式调用 then，每次都会在内部生成一个新的 Promise，然后执行 then，在执行的过程中不断向微任务 (microtask) 推入新的函数，因此直至微任务的队列清空后才会执行下一波的 macrotask。</p></blockquote> <blockquote><p>墙裂推荐阅读：</p> <ul><li><a href="https://juejin.im/post/59e85eebf265da430d571f89" target="_blank" rel="noopener noreferrer">这一次，彻底弄懂 JavaScript 执行机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://mp.weixin.qq.com/s/8xyccve0e9uA2mnk07CAWw" target="_blank" rel="noopener noreferrer">面试问到 Event Loop，这样回答最完美<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 👏</li> <li><a href="https://juejin.im/post/5c9a43175188252d876e5903" target="_blank" rel="noopener noreferrer">Eventloop 不可怕，可怕的是遇上 Promise<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 😫</li></ul></blockquote> <h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="header-anchor">#</a> 垃圾回收机制</h2> <p>JavaScript 会在创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放。 而这个释放无用变量内存的过程被称为垃圾回收。</p> <h3 id="内存模型与生命周期"><a href="#内存模型与生命周期" class="header-anchor">#</a> 内存模型与生命周期</h3> <p><strong>内存模型</strong></p> <ol><li>基本类型数据以及复杂类型数据都是如何存放的呢？</li></ol> <ul><li>基本类型普遍被存放在『栈』中，而复杂类型是被存放在堆内存的。</li></ul> <ol start="2"><li>执行栈的函数是如何使用内存堆的复杂类型？</li></ol> <ul><li>实际上，执行栈的函数上下文会保存一个内存堆对应复杂类型对象的内存地址，通过引用来使用复杂类型对象。</li></ul> <ol start="3"><li>是否所有的基本类型都储存在栈中呢？</li></ol> <ul><li>并不是，当一个基本类型被闭包引用之后，就可以长期存在于内存中，这个时候即使他是基本类型，也是会被存放在堆中的。</li></ul> <p><strong>生命周期</strong></p> <p>不管什么程序语言，内存生命周期基本都是一样的：分配 =&gt; 使用（读、写）=&gt; 释放</p> <blockquote><p>所有语言第二部分都是明确的。第一和第三部分在底层语言中是明确的，但在像 JavaScript 这些高级语言中，大部分都是隐含的。</p></blockquote> <h3 id="v8-分代式回收机制"><a href="#v8-分代式回收机制" class="header-anchor">#</a> V8 分代式回收机制</h3> <p>V8 的 GC （Garbage Collection）算法策略基于分代式回收机制，该机制又基于<strong>世代假说。</strong></p> <p>该假说有两个特点：</p> <ul><li>大部分新生对象倾向于早死</li> <li>不死的对象，会活得更久</li></ul> <p>基于这个理论，V8 引擎根据对象的存活时间将内存（堆）分为新生代（new space）和老生代（old space）两部分。</p> <ul><li>新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。</li> <li>老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象。</li></ul> <p>因为内存分代，并对不同分代的内存采用不同的高效算法进行垃圾回收。V8 实现了准确式的 GC。</p> <p><strong>全停顿（Stop The World）</strong></p> <p>在介绍垃圾回收算法之前，先了解一个概念，全停顿：</p> <p>为避免应用逻辑与垃圾回收器看到的情况不一致，垃圾回收算法在执行前，需要将应用逻辑暂停，执行完垃圾回收后再执行应用逻辑，这种行为称为 「全停顿」。例如，如果一次 GC 需要 50ms，应用逻辑就会暂停 50ms。</p> <h4 id="新生代-scavenge-算法"><a href="#新生代-scavenge-算法" class="header-anchor">#</a> 新生代 Scavenge 算法</h4> <p>新生代中的对象主要通过 Scavenge 算法进行垃圾回收。Scavenge 的具体实现，主要采用了 Cheney 算法。</p> <p><img src="/assets/img/scavenge.b8835718.png" alt="Scavenge 算法"></p> <ol><li>在新生代空间中，将堆内存空间分为两部分（semispace）。</li> <li>在这两个空间中，必定有一个空间是使用的（From 空间），另一个空间是空闲的（To 空间）。</li> <li>在 From 空间中分配新对象内存，当 From 空间被占满时，新生代 GC 就会启动执行。</li> <li>检查 From 空间的存活对象，若对象存活，则检查对象是否符合晋升条件，若符合条件则晋升到老生代，否则将对象从 From 空间复制到 To 空间。</li> <li>若对象失活，则销毁失活对象并释放空间。</li> <li>当复制完成后，将 From 空间和 To 空间互换，进行角色翻转（flip），这样 GC 就结束了。</li></ol> <p>Scavenge/Cheney 算法的缺点是，它的算法机制决定了只能利用一半的内存空间。但是新生代中的对象生存周期短、存活对象少，进行对象复制的成本不是很高，因而非常适合这种场景。</p> <h4 id="老生代算法"><a href="#老生代算法" class="header-anchor">#</a> 老生代算法</h4> <p>首先，老生代空间中的对象也是从新生代中晋升而来的，对象晋升到老生代后，将接受新的垃圾回收算法处理。</p> <p><img src="/assets/img/duixiangjinsheng.7d503b3c.png" alt="对象晋升"></p> <p><strong>对象晋升的条件：</strong></p> <ol><li><p>对象是否经历过一次 Scavenge 算法回收。👆</p> <blockquote><p>对象从 From 空间复制 To 空间时，会<strong>检查对象的内存地址</strong>来判断对象是否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</p></blockquote></li> <li><p>To 空间的对象内存使用占比是否超过 25%的限制。</p> <blockquote><p>当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置为 25%的比例的原因是，当完成 Scavenge 回收后，To 空间将翻转成 From 空间，继续进行对象内存的分配。若占比过大，将影响后续内存分配。</p></blockquote></li></ol> <p>老生代中的对象有两个特点，第一是存活对象多，第二个存活时间长。</p> <p>若在老生代中使用 Scavenge 算法进行垃圾回收，将会导致复制存活对象的效率不高，且还会浪费一半的空间。</p> <p>因而，V8 在老生代采用**标记清除（Mark-Sweep ）<strong>和</strong>标记压缩（Mark-Compact ）**两种算法进行垃圾回收。</p> <p>Mark-Sweep，分为标记和清除两个阶段：</p> <ol><li>标记阶段，它将遍历堆中所有对象，并对存活的对象进行标记。</li> <li>清除阶段，对未标记对象的空间进行回收。</li></ol> <blockquote><p>与 Scavenge 算法不同，Mark-Sweep 不会对内存一分为二，因此不会浪费空间。但是，经历过一次 Mark-Sweep 之后，内存的空间将会变得不连续，这样会对后续内存分配造成问题。比如，当需要分配一个比较大的对象时，没有任何一个碎片内支持分配，这将提前触发一次垃圾回收，尽管这次垃圾回收是没有必要的。</p></blockquote> <p>清除对象后会造成堆内存出现碎片的情况，为了提高对内存的利用，当碎片超过一定限制后会启动 Mark-Compact 压缩算法。</p> <blockquote><p>Mark-Compact 是在 Mark-Sweep 算法上进行了改进，标记阶段与 Mark-Sweep 相同，但是对未标记的对象处理方式不同。Mark-Sweep 是对未标记的对象立即进行回收，Mark-Compact 则是将存活的对象移动到一边，直到所有对象都移动完成然后清理掉不需要的内存。</p></blockquote> <p>由于 Mark-Compact 需要移动对象，所以执行速度上，比 Mark-Sweep 要慢。所以，V8 主要使用 Mark-Sweep 算法，然后在当空间内存分配不足时，采用 Mark-Compact 算法。</p> <p><strong>增量标记（Incremental Marking）</strong></p> <p>在新生代中，由于存活对象少，垃圾回收效率高，全停顿时间短，造成的影响小。但是老生代中，存活对象多，垃圾回收时间长，全停顿造成的影响大。长时间的 GC，会导致应用暂停和无响应，将会导致糟糕的用户体验。</p> <p>为了减少全停顿时间过长带来的性能问题，2011 年，V8 对标记进行了优化，从 stop-the-world 标记切换到增量标记，即将一次停顿进行的标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，这样交替多次后完成标记，从而不至于让应用出现停顿情况。改进后的标记方式，最大停顿时间减少到原来的 1/6。</p> <p><strong>并发标记</strong></p> <p>在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，可以点击 <a href="https://v8project.blogspot.com/2018/06/concurrent-marking.html" target="_blank" rel="noopener noreferrer">该博客<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 详细阅读。</p> <p><strong>内存泄漏</strong></p> <p>会引起内存泄漏的几种禁忌：</p> <ul><li><p>滥用闭包</p></li> <li><p>滥用全局变量：直接用全局变量赋值，在函数中滥用 this 指向全局对象</p></li> <li><p>不销毁定时器和回调</p></li> <li><p>DOM 引用不规范，很多时候，我们对 Dom 的操作，会把 Dom 的引用保存在一个数组或者 Map 中，往往无法对其进行内存回收。</p></li></ul> <blockquote><p>ES6 中引入 WeakSet 和 WeakMap 两个新的概念，来解决引用造成的内存回收问题。WeakSet 和 WeakMap 对于值的引用可以忽略不计，他们对于值的引用是弱引用，内存回收机制，不会考虑这种引用。当其他引用被消除后，引用就会从内存中被释放。</p></blockquote> <h2 id="事件机制"><a href="#事件机制" class="header-anchor">#</a> 事件机制</h2> <h3 id="事件触发三阶段"><a href="#事件触发三阶段" class="header-anchor">#</a> 事件触发三阶段</h3> <ol><li><strong>捕获：</strong> <code>window</code> 往事件触发处传播，遇到注册的捕获事件会触发。</li> <li>传播到事件触发处时触发注册的事件。</li> <li><strong>冒泡：</strong> 从事件触发处往 <code>window</code> 传播，遇到注册的冒泡事件会触发。</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 以下会先打印冒泡然后是捕获</span>
node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">'click'</span><span class="token punctuation">,</span>
  <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'冒泡'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">false</span>
<span class="token punctuation">)</span>
node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">'click'</span><span class="token punctuation">,</span>
  <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'捕获 '</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">true</span>
<span class="token punctuation">)</span>
</code></pre></div><ul><li>阻止事件冒泡 e.stopPropagation()</li></ul> <h3 id="注册事件"><a href="#注册事件" class="header-anchor">#</a> 注册事件</h3> <p>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> 。<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性</p> <ul><li><code>capture</code>，布尔值，和 <code>useCapture</code> 作用一样</li> <li><code>once</code>，布尔值，值为 <code>true</code> 表示该回调只会调用一次，调用后会移除监听</li> <li><code>passive</code>，布尔值，表示永远不会调用 <code>preventDefault</code></li></ul> <p>一般来说，我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p> <div class="language-js extra-class"><pre class="language-js"><code>node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">'click'</span><span class="token punctuation">,</span>
  <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    event<span class="token punctuation">.</span><span class="token function">stopImmediatePropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'冒泡'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">false</span>
<span class="token punctuation">)</span>
<span class="token comment">// 点击 node 只会执行上面的函数，该函数不会执行</span>
node<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>
  <span class="token string">'click'</span><span class="token punctuation">,</span>
  <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'捕获 '</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token boolean">true</span>
<span class="token punctuation">)</span>
</code></pre></div><h3 id="事件代理"><a href="#事件代理" class="header-anchor">#</a> 事件代理</h3> <p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上，即事件代理。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>list<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>项目 1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>项目 2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>item3<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>项目 3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token comment">&lt;!-- 随时会新增更多的 li 标签 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">let</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'#list'</span><span class="token punctuation">)</span>
  ul<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>事件代理的方式相对于直接给目标注册事件来说，有以下优点</p> <ul><li>节省内存</li> <li>不需要给子节点注销事件</li></ul> <h2 id="bom-操作"><a href="#bom-操作" class="header-anchor">#</a> BOM 操作</h2> <p>BOM（浏览器对象模型）是浏览器本身的一些信息的设置和获取，例如获取浏览器的宽度、高度，设置让浏览器跳转到哪个地址。</p> <ul><li>window.screen 对象：包含有关用户屏幕的信息</li> <li>window.location 对象：用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面</li> <li>window.history 对象：浏览历史的前进后退等</li> <li>window.navigator 对象：常常用来获取浏览器信息、是否移动端访问等等</li></ul> <p>举几个例子🌰</p> <ul><li>获取屏幕的宽度和高度 <code>screen.width</code> 与 <code>screen.height</code></li> <li>复制代码获取网址、协议、path、参数、hash 等</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 例如当前网址是 https://xxx.com/demo/frontend?a=10&amp;b=10#some</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>href<span class="token punctuation">)</span>  <span class="token comment">// https://xxx.com/demo/frontend?a=10&amp;b=10#some</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>protocol<span class="token punctuation">)</span> <span class="token comment">// https:</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>pathname<span class="token punctuation">)</span> <span class="token comment">// /demo/frontend</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>search<span class="token punctuation">)</span> <span class="token comment">// ?a=10&amp;b=10</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>location<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token comment">// #some</span>
</code></pre></div><ul><li>复制代码另外，还有调用浏览器的前进、后退功能等 <code>history.back()</code>与<code>history.forward()</code></li> <li>复制代码获取浏览器特性（即俗称的 UA）然后识别客户端，例如判断是不是 Chrome 浏览器</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> ua <span class="token operator">=</span> navigator<span class="token punctuation">.</span>userAgent
<span class="token keyword">var</span> isChrome <span class="token operator">=</span> ua<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'Chrome'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>isChrome<span class="token punctuation">)</span>
</code></pre></div><h2 id="ajax-与-跨域"><a href="#ajax-与-跨域" class="header-anchor">#</a> Ajax 与 跨域</h2> <h3 id="ajax"><a href="#ajax" class="header-anchor">#</a> Ajax</h3> <blockquote><p>推荐阅读：<a href="https://juejin.im/post/58c883ecb123db005311861a" target="_blank" rel="noopener noreferrer">Ajax 知识体系大梳理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h3 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h3> <p><strong>同源策略：</strong></p> <p>因为浏览器出于安全考虑，限制了从同一个源加载的文档或脚本与来自另一个源的资源进行交互，即同源策略，这是一个用于隔离潜在恶意文件的重要安全机制。</p> <p>同源是指&quot;协议+域名+端口&quot;三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。</p> <p>协议、域名或者端口有一个不同就算跨域，而且所有的跨域请求都必须经过信息提供方允许，否则 Ajax 请求就会失败。</p> <p>浏览器中的大部分内容都是受同源策略限制的，但是以下三个 HTML 标签可以不受限制，可以跨域加载资源：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>xxx<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>xxx<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>xxx<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>因此这三个标签分别有它们的使用场景：</p> <blockquote><p>img 用于打点统计，统计网站可能是其他域</p> <p>link、script 可以使用 CDN，CDN 加载的也是其他域资源</p> <p>script 可以用于 JSONP</p></blockquote> <h4 id="几种实现跨域的常用方法"><a href="#几种实现跨域的常用方法" class="header-anchor">#</a> 几种实现跨域的常用方法</h4> <p><strong>1. JSONP</strong></p> <p>jsonp 本质上是一个 Hack，它的原理就是利用<code>&lt;script&gt;</code>标签不受同源策略限制的特性，通过 <code>&lt;script&gt;</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据，从而实现跨域操作。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
    <span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>

<span class="token comment">// 或者是下面这种方式</span>
<span class="token operator">&lt;</span>script<span class="token operator">&gt;</span>
window<span class="token punctuation">.</span><span class="token function-variable function">callback</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token operator">&lt;</span>script<span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script src <span class="token operator">=</span> <span class="token string">&quot;http://demo.com/api.js&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>script<span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token comment">// 该接口将返回 callback({x:10, y:20}) 执行 callback 方法</span>
</code></pre></div><ol><li>提前定义好跨域请求的接口要返回的函数</li> <li>通过 script 跨域加载 js 文件，绕过浏览器的同源策略</li> <li>加载请求的 js 文件，同时执行 callback 函数 得到请求的数据</li></ol> <p>JSONP 使用简单且兼容性不错，但是它只限于 <code>get</code> 请求。</p> <p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP，以下是简单实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token parameter">url<span class="token punctuation">,</span> jsonpCallback<span class="token punctuation">,</span> success</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span>
  script<span class="token punctuation">.</span>src <span class="token operator">=</span> url
  script<span class="token punctuation">.</span>async <span class="token operator">=</span> <span class="token boolean">true</span>
  script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span>
  window<span class="token punctuation">[</span>jsonpCallback<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    success <span class="token operator">&amp;&amp;</span> <span class="token function">success</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token string">'http://xxx'</span><span class="token punctuation">,</span> <span class="token string">'callback'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>2. CORS</strong></p> <p>CORS 是目前主流的跨域解决方案，跨域资源共享 (CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</p> <p>CORS 需要浏览器和后端同时支持。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p> <blockquote><p>IE 8 和 9 需要通过 <code>XDomainRequest</code> 来实现。</p></blockquote> <p>服务端通过设置 http header 的 <code>Access-Control-Allow-Origin</code> 属性就可以开启 CORS。</p> <p>该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 不同的后端语言会有不同</span>
response<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Access-Control-Allow-Origin&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;http://test.com&quot;</span><span class="token punctuation">)</span> <span class="token comment">// 不建议直接写 '*'</span>
</code></pre></div><blockquote><p>在生产环境中建议用成熟的开源中间件解决问题。</p></blockquote> <p><strong>其它跨域方案</strong></p> <ol><li><p>HTML5 XMLHttpRequest 有一个 API，<code>postMessage()</code>方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 这种方式通常用于获取嵌入页面中的第三方页面数据。</span>
<span class="token comment">// 一个页面发送消息，另一个页面判断来源并接收消息。</span>
<span class="token comment">// 发送消息端</span>
window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token string">'http://test.com'</span><span class="token punctuation">)</span>
<span class="token comment">// 接收消息端</span>
<span class="token keyword">var</span> mc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
mc<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> <span class="token parameter">event</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> origin <span class="token operator">=</span> event<span class="token punctuation">.</span>origin <span class="token operator">||</span> event<span class="token punctuation">.</span>originalEvent<span class="token punctuation">.</span>origin
  <span class="token keyword">if</span> <span class="token punctuation">(</span>origin <span class="token operator">===</span> <span class="token string">'http://test.com'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'验证通过'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></li> <li><p>WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了，因此可以跨域。</p></li> <li><p>window.name + iframe：window.name 属性值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值，我们可以利用这个特点进行跨域。</p></li> <li><p>location.hash + iframe：a.html 欲与 c.html 跨域相互通信，通过中间页 b.html 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。</p></li> <li><p>document.domain + iframe： 该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。我们只需要给页面添加 <code>document.domain = 'test.com'</code> 表示二级域名都相同就可以实现跨域，两个页面都通过 js 强制设置<code>document.domain</code>为基础主域，就实现了同域。</p></li></ol> <blockquote><p>推荐阅读：<a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1#heading-19" target="_blank" rel="noopener noreferrer">九种跨域方式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h2 id="存储"><a href="#存储" class="header-anchor">#</a> 存储</h2> <h3 id="前端存储有几种方式？区别是什么？🌟"><a href="#前端存储有几种方式？区别是什么？🌟" class="header-anchor">#</a> 前端存储有几种方式？区别是什么？🌟</h3> <p><strong>一共 5 种方式：</strong> cookies、localstorage、sessionstorage、Web SQL（已废弃）、IndexedDB</p> <ol><li><p><strong>Cookies：</strong></p> <p>本身是用于客户端和服务端通信的，但是它有本地存储的功能，于是就被 ”借用“。是在 HTML5 标准前本地储存的主要方式。</p> <p>优点是是兼容性好，但缺点很多：数据存储量太小，只有 4kb。所有 http 请求头自动携带 cookie ，浪费流量，影响获取资源的效率。 每个 domain 限制 20 个 cookie，API 使用起来麻烦需要自行封装。</p></li> <li><p><strong>localStorage：</strong></p> <p>HTML5 加入的以键值对 (Key-Value) 为标准的方式，专门为存储而设计。优点是操作方便。永久性储存（除非手动删除），并可用于所有同源（相同的域名、协议和端口）窗口（或标签页），大小为 5M，兼容 IE8+</p> <blockquote><p>IOS safari 隐身模式下，localStorage.getItem 会报错，建议统一使用 try-catch 封装。</p></blockquote></li> <li><p><strong>sessionStorage：</strong></p> <p>与 localStorage 基本类似，API 简单易用。区别是 sessionStorage 在当页面关闭后会被清理，而且与 cookie、localStorage 不同，他不能在所有同源窗口中共享，是会话级别的储存方式</p> <blockquote><p>这里需要注意的是，页面及标签页仅指顶级窗口，如果一个标签页包含多个 iframe 标签且他们属于同源页面，那么他们之间是可以共享 sessionStorage 的。</p></blockquote></li> <li><p><strong>Web SQL：</strong></p> <p>2010 年被 W3C 废弃的本地数据库数据存储方案，但是主流浏览器（火狐除外）都已经有了相关的实现，web sql 类似于 SQLite，是真正意义上的关系型数据库，用 sql 进行操作，当我们用 JavaScript 时要进行转换，较为繁琐。</p></li> <li><p><strong>IndexedDB：</strong></p> <p>是被正式纳入 HTML5 标准的数据库储存方案，它是 NoSQL 数据库，用键值对进行储存，可以进行快速读取操作，非常适合 web 场景，同时用 JavaScript 进行操作会非常方便。</p></li></ol> <p>速览表：</p> <table><thead><tr><th style="text-align:center;">特性</th> <th style="text-align:center;">cookie</th> <th style="text-align:center;">localStorage</th> <th style="text-align:center;">sessionStorage</th> <th style="text-align:center;">indexDB</th></tr></thead> <tbody><tr><td style="text-align:center;">数据生命周期</td> <td style="text-align:center;">一般由服务器生成，可以设置过期时间</td> <td style="text-align:center;">除非被清理，否则一直存在</td> <td style="text-align:center;">页面关闭就清理</td> <td style="text-align:center;">除非被清理，否则一直存在</td></tr> <tr><td style="text-align:center;">数据存储大小</td> <td style="text-align:center;">4K</td> <td style="text-align:center;">5M</td> <td style="text-align:center;">5M</td> <td style="text-align:center;">无限</td></tr> <tr><td style="text-align:center;">与服务端通信</td> <td style="text-align:center;">每次都会携带在 header 中，对于请求性能影响</td> <td style="text-align:center;">不参与</td> <td style="text-align:center;">不参与</td> <td style="text-align:center;">不参与</td></tr></tbody></table> <p><strong>建议：</strong> 从上表可以看出，<code>cookie</code> 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 <code>localStorage</code> 和 <code>sessionStorage</code> 。对于不怎么改变的数据尽量使用 <code>localStorage</code> 存储，否则可以用 <code>sessionStorage</code> 存储。</p> <p>对于 <code>cookie</code>，我们还需要注意安全性。</p> <table><thead><tr><th style="text-align:center;">属性</th> <th style="text-align:center;">作用</th></tr></thead> <tbody><tr><td style="text-align:center;">value</td> <td style="text-align:center;">如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</td></tr> <tr><td style="text-align:center;">http-only</td> <td style="text-align:center;">不能通过 JS 访问 Cookie，减少 XSS 攻击</td></tr> <tr><td style="text-align:center;">secure</td> <td style="text-align:center;">只能在协议为 HTTPS 的请求中携带</td></tr> <tr><td style="text-align:center;">same-site</td> <td style="text-align:center;">规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击</td></tr></tbody></table> <blockquote><p>推荐阅读：<a href="https://segmentfault.com/a/1190000005927232" target="_blank" rel="noopener noreferrer">聊一聊前端存储那些事<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Frontend/JavaScript/" class="prev">JavaScript</a></span> <span class="next"><a href="/Frontend/Engineering/">概念</a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.931542fe.js" defer></script><script src="/assets/js/2.0fac7938.js" defer></script><script src="/assets/js/5.96e50475.js" defer></script>
  </body>
</html>
