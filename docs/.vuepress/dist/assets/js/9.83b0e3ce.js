(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{218:function(v,_,e){v.exports=e.p+"assets/img/mvvm.d55fe97b.png"},219:function(v,_,e){v.exports=e.p+"assets/img/VirtualDom.1b6e8456.png"},245:function(v,_,e){"use strict";e.r(_);var t=e(0),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"通识"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通识"}},[v._v("#")]),v._v(" 通识")]),v._v(" "),t("h2",{attrs:{id:"为什么使用框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用框架"}},[v._v("#")]),v._v(" 为什么使用框架")]),v._v(" "),t("ol",[t("li",[v._v("组件化：高度的组件化可以使我们的工程项目易于维护、易于组合拓展。")]),v._v(" "),t("li",[v._v("天然分层：JQuery 时代的代码大部分情况下是面条代码，耦合严重，而现代框架不管是 MVC、MVP 还是 MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。")]),v._v(" "),t("li",[v._v("生态：主流前端框架都自带生态，不管是数据流管理架构还是 UI 库都有成熟的解决方案。")]),v._v(" "),t("li",[v._v("开发效率：现代前端框架都默认自动更新 DOM，而非我们手动操作，解放了开发者的手动 DOM 成本，提高开发效率，从根本上解决了 UI 与状态同步问题。")])]),v._v(" "),t("h2",{attrs:{id:"mvvm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvvm"}},[v._v("#")]),v._v(" MVVM")]),v._v(" "),t("h3",{attrs:{id:"概念理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念理解"}},[v._v("#")]),v._v(" 概念理解")]),v._v(" "),t("p",[t("strong",[v._v("MVVM")]),v._v(" 即 "),t("strong",[v._v("Model-View-ViewModel")]),v._v(" 模式。")]),v._v(" "),t("p",[t("strong",[v._v("1. View 层")])]),v._v(" "),t("p",[v._v("在 MVVM 里，整个 View 层就是一个动态视图模板。另外，除了定义界面的结构、布局外，它更是 ViewModel 层的数据和状态展示的地方。View 层不负责处理状态，View 层做的是 数据绑定的声明、 指令的声明、 事件绑定的声明。")]),v._v(" "),t("p",[t("strong",[v._v("2. Model 层")])]),v._v(" "),t("p",[v._v("对应数据层的域模型（融合了行为和数据的域的对象模型），它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 ViewModel 中视图的 Model。")]),v._v(" "),t("p",[t("strong",[v._v("3. ViewModel 层")])]),v._v(" "),t("p",[v._v("把 View 层需要的数据暴露，并对 View 层的数据绑定声明、 指令声明、 事件绑定声明负责，也就是负责处理 View 层的具体业务逻辑。ViewModel 底层会做好绑定属性的监听。当 ViewModel 中数据变化，View 层会得到更新；而当 View 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。一旦值变化，View 层绑定的 ViewModel 中的数据也会得到自动更新。")]),v._v(" "),t("p",[t("img",{attrs:{src:e(218),alt:"MVVM"}})]),v._v(" "),t("p",[v._v("在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合。")]),v._v(" "),t("p",[v._v("在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。")]),v._v(" "),t("p",[v._v("ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。")]),v._v(" "),t("p",[v._v("在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。")]),v._v(" "),t("p",[v._v("todo: 双向绑定的实现原理")]),v._v(" "),t("h3",{attrs:{id:"mvvm-的优缺点？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvvm-的优缺点？"}},[v._v("#")]),v._v(" MVVM 的优缺点？")]),v._v(" "),t("p",[t("strong",[v._v("优点：")])]),v._v(" "),t("ul",[t("li",[v._v("分离视图（View）和模型（Model）, 降低代码耦合，提高视图或者逻辑的重用性。")]),v._v(" "),t("li",[v._v("提高可测试性，ViewModel 的存在可以帮助开发者更好地编写测试代码")]),v._v(" "),t("li",[v._v("自动更新 dom，利用双向绑定，数据更新后视图自动更新，让开发者从繁琐的手动 dom 中解放")])]),v._v(" "),t("p",[t("strong",[v._v("缺点：")])]),v._v(" "),t("ul",[t("li",[v._v("Bug 很难被调试")])]),v._v(" "),t("blockquote",[t("p",[v._v("因为使用双向绑定的模式，当你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。")]),v._v(" "),t("p",[v._v("另外，数据绑定的声明是指令式地写在 View 的模版当中的，这些内容是没办法去打断点 debug 的。")])]),v._v(" "),t("ul",[t("li",[v._v("对于过大的项目，数据绑定需要花费更多的内存")])]),v._v(" "),t("blockquote",[t("p",[v._v("对于大型的图形应用程序，视图状态较多，ViewModel 的构建和维护的成本都会比较高。")]),v._v(" "),t("p",[v._v("一个大的模块中的 model 也会很大，虽然方便地保证了数据的一致性，但是如果长期持有不释放也会导致更多的内存占用。")])]),v._v(" "),t("h2",{attrs:{id:"virtual-dom"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom"}},[v._v("#")]),v._v(" Virtual Dom")]),v._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",[v._v("Virtual DOM 是对真实 DOM 的抽象，本质上是 JavaScript 对象，这个对象就是对 DOM 更加轻量级地描述。")])]),v._v(" "),t("p",[t("img",{attrs:{src:e(219),alt:"Virtual Dom"}})]),v._v(" "),t("h3",{attrs:{id:"为什么需要-virtual-dom？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要-virtual-dom？"}},[v._v("#")]),v._v(" 为什么需要 Virtual DOM？")]),v._v(" "),t("p",[t("strong",[v._v("保证性能下限")])]),v._v(" "),t("p",[v._v("减少因为操作 DOM 导致的性能耗费是前端性能优化的一个重要方面。其实不仅仅是操作 DOM 相对较慢，更因为频繁变动 DOM 会造成浏览器的回流或者重绘，这些都会特别耗费性能。")]),v._v(" "),t("p",[v._v("因此我们利用 JS 对象来模拟 DOM 对象抽象出虚拟 DOM，经过 diff 找出最小差异，然后在进行批量 patch 的过程中尽可能地将差异一次性更新到 DOM 中，这种操作虽然比不上手动优化，但是比起粗暴的 DOM 操作性能要好很多，这样保证了 DOM 不会出现性能特别差的情况，, 因此虚拟 DOM 可以保证性能下限。")]),v._v(" "),t("blockquote",[t("p",[v._v("当然在实际操作中，我们还需要给每个节点一个唯一标识，作为判断是同一个节点的依据。所以这也是 Vue 和 React 中推荐列表里的节点使用唯一的 "),t("code",[v._v("key")]),v._v(" 来保证性能的原因。")])]),v._v(" "),t("p",[t("strong",[v._v("无须手动操作 DOM")])]),v._v(" "),t("p",[v._v("现代前端框架的一个基本要求就是无须手动操作 DOM，一方面是因为手动操作 DOM 无法保证程序性能，多人协作的项目中如果 review 不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动 DOM 操作可以大大提高开发效率。")]),v._v(" "),t("p",[t("strong",[v._v("跨平台")])]),v._v(" "),t("p",[v._v("Virtual DOM 最初的目的，就是更好的跨平台。比如 Node.js 就没有 DOM，如果想实现 SSR（服务端渲染），那么一个方式就是借助 Virtual DOM，因为 Virtual DOM 本身是 JavaScript 对象。")]),v._v(" "),t("p",[t("strong",[v._v("🗣缺点：无法进行极致的优化")]),v._v(" 在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化，比如 VScode 采用直接手动操作 DOM 的方式进行极端的性能优化。")]),v._v(" "),t("h3",{attrs:{id:"关键步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关键步骤"}},[v._v("#")]),v._v(" 关键步骤")]),v._v(" "),t("ul",[t("li",[v._v("用 JavaScript 对象结构表示 DOM 树的结构，然后用这个树构建一个真正的 DOM 树，插到文档当中。")]),v._v(" "),t("li",[v._v("当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树使用 Diff 算法进行比较，记录两棵树的差异。")]),v._v(" "),t("li",[v._v("把所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图更新。")])]),v._v(" "),t("p",[t("strong",[v._v("Diff 算法及优化：")])]),v._v(" "),t("p",[v._v("Diff 的目的就是比较新旧 Virtual DOM Tree 找出差异并更新，所以 Diff 算法会直接影响 Virtual DOM 的性能，也是其最核心和最难理解的部分。")]),v._v(" "),t("p",[v._v("要比较 Virtual DOM Tree 的差异，理论上的时间复杂度高达 O(n^3)，这是一个奇高无比的时间复杂度，很显然选择这种低效的算法是无法满足我们对程序性能的基本要求的。")]),v._v(" "),t("p",[v._v("好在我们实际开发中，很少会出现跨层级的 DOM 变更。通常情况下的 DOM 变更是同级的，因此在现代的各种 Virtual DOM 库都是只比较同级差异，在这种情况下我们的时间复杂度是 O(n)。")]),v._v(" "),t("p",[v._v("snabbdom.js 是社区内主流的 Virtual DOM 实现，vue 2.0 阶段与 snabbdom.js 一样都采用了「双端比较算法」。")]),v._v(" "),t("p",[v._v("而 vue 3.0 会借鉴 inferno.js 的算法进行优化，具体的优化思想可以先参考 "),t("a",{attrs:{href:"https://github.com/NervJS/nerv/issues/3",target:"_blank",rel:"noopener noreferrer"}},[v._v("diff 算法原理概述"),t("OutboundLink")],1),v._v("，其中一个核心的思想就是利用 LIS（最长递增子序列）的思想做动态规划，找到最小的移动次数。")]),v._v(" "),t("blockquote",[t("p",[v._v("inferno.js 号称是最快的 react-like 框架（虽然 inferno.js 性能强悍的原因不仅仅是算法，但是其 diff 算法的确是目前最快的）")])]),v._v(" "),t("h2",{attrs:{id:"路由原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#路由原理"}},[v._v("#")]),v._v(" 路由原理")]),v._v(" "),t("p",[v._v("前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式。")]),v._v(" "),t("ul",[t("li",[v._v("hash 模式")]),v._v(" "),t("li",[v._v("history 模式")])]),v._v(" "),t("p",[t("code",[v._v("www.test.com/##/")]),v._v(" 就是 "),t("code",[v._v("Hash URL")]),v._v("，当 "),t("code",[v._v("##")]),v._v(" 后面的哈希值发生变化时，不会向服务器请求数据，可以通过 "),t("code",[v._v("hashchange")]),v._v(" 事件来监听到 "),t("code",[v._v("URL")]),v._v(" 的变化，从而进行跳转页面。")]),v._v(" "),t("p",[t("code",[v._v("History")]),v._v("模式是 "),t("code",[v._v("HTML5")]),v._v(" 新推出的功能，比之 "),t("code",[v._v("Hash URL")]),v._v(" 更加美观。")]),v._v(" "),t("p",[v._v("todo: 两者的区别")])])}),[],!1,null,null,null);_.default=a.exports}}]);