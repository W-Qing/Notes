# 通识

## 为什么使用框架

1. **组件化**：高度的组件化可以使我们的工程项目易于维护、易于组合拓展。
2. **天然分层**：JQuery 时代的代码大部分情况下是面条代码，耦合严重，而现代框架不管是 MVC、MVP 还是 MVVM 模式都能帮助我们进行分层，代码解耦更易于读写。
3. **生态**：主流前端框架都自带生态，不管是数据流管理架构还是 UI 库都有成熟的解决方案。
4. **开发效率**：现代前端框架都默认自动更新 DOM，而非我们手动操作，解放了开发者的手动 DOM 成本，提高开发效率，从根本上解决了 UI 与状态同步问题。

## MVVM

### 概念理解
**MVVM** 即 **Model-View-ViewModel** 模式。

**1. View 层**

在 MVVM 里，整个 View 层就是一个动态视图模板。另外，除了定义界面的结构、布局外，它更是 ViewModel 层的数据和状态展示的地方。View 层不负责处理状态，View 层做的是 数据绑定的声明、 指令的声明、 事件绑定的声明。

**2. Model 层**

对应数据层的域模型（融合了行为和数据的域的对象模型），它主要做域模型的同步。通过 Ajax/fetch 等 API 完成客户端和服务端业务 Model 的同步。在层间关系里，它主要用于抽象出 ViewModel 中视图的 Model。

**3. ViewModel 层**

把 View 层需要的数据暴露，并对 View 层的数据绑定声明、 指令声明、 事件绑定声明负责，也就是负责处理 View 层的具体业务逻辑。ViewModel 底层会做好绑定属性的监听。当 ViewModel 中数据变化，View 层会得到更新；而当 View 中声明了数据的双向绑定（通常是表单元素），框架也会监听 View 层（表单）值的变化。一旦值变化，View 层绑定的 ViewModel 中的数据也会得到自动更新。

![MVVM](~@frontendImg/framework/mvvm.png)

在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合。

在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。

ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。

在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。

todo: 双向绑定的实现原理

### MVVM 的优缺点？
**优点：**

- 分离视图（View）和模型（Model）, 降低代码耦合，提高视图或者逻辑的重用性。
- 提高可测试性，ViewModel 的存在可以帮助开发者更好地编写测试代码
- 自动更新 dom，利用双向绑定，数据更新后视图自动更新，让开发者从繁琐的手动 dom 中解放

**缺点：**

- Bug 很难被调试

> 因为使用双向绑定的模式，当你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。
>
> 另外，数据绑定的声明是指令式地写在 View 的模版当中的，这些内容是没办法去打断点 debug 的。

- 对于过大的项目，数据绑定需要花费更多的内存

> 对于大型的图形应用程序，视图状态较多，ViewModel 的构建和维护的成本都会比较高。
>
> 一个大的模块中的 model 也会很大，虽然方便地保证了数据的一致性，但是如果长期持有不释放也会导致更多的内存占用。

## Virtual Dom

::: tip

Virtual DOM 是对真实 DOM 的抽象，本质上是 JavaScript 对象，这个对象就是对 DOM 更加轻量级地描述。

:::

![Virtual Dom](~@frontendImg/framework/VirtualDom.png)

### 为什么需要 Virtual DOM？

**保证性能下限**

减少因为操作 DOM 导致的性能耗费是前端性能优化的一个重要方面。其实不仅仅是操作 DOM 相对较慢，更因为频繁变动 DOM 会造成浏览器的回流或者重绘，这些都会特别耗费性能。

因此我们利用 JS 对象来模拟 DOM 对象抽象出虚拟 DOM，经过 diff 找出最小差异，然后在进行批量 patch 的过程中尽可能地将差异一次性更新到 DOM 中，这种操作虽然比不上手动优化，但是比起粗暴的 DOM 操作性能要好很多，这样保证了 DOM 不会出现性能特别差的情况，, 因此虚拟 DOM 可以保证性能下限。

> 当然在实际操作中，我们还需要给每个节点一个唯一标识，作为判断是同一个节点的依据。所以这也是 Vue 和 React 中推荐列表里的节点使用唯一的 `key` 来保证性能的原因。

**无须手动操作 DOM**

现代前端框架的一个基本要求就是无须手动操作 DOM，一方面是因为手动操作 DOM 无法保证程序性能，多人协作的项目中如果 review 不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动 DOM 操作可以大大提高开发效率。

**跨平台**

Virtual DOM 最初的目的，就是更好的跨平台。比如 Node.js 就没有 DOM，如果想实现 SSR（服务端渲染），那么一个方式就是借助 Virtual DOM，因为 Virtual DOM 本身是 JavaScript 对象。

**🗣缺点：无法进行极致的优化** 在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化，比如 VScode 采用直接手动操作 DOM 的方式进行极端的性能优化。

### 关键步骤

- 用 JavaScript 对象结构表示 DOM 树的结构，然后用这个树构建一个真正的 DOM 树，插到文档当中。
- 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树使用 Diff 算法进行比较，记录两棵树的差异。
- 把所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图更新。

**Diff 算法及优化：**

Diff 的目的就是比较新旧 Virtual DOM Tree 找出差异并更新，所以 Diff 算法会直接影响 Virtual DOM 的性能，也是其最核心和最难理解的部分。

要比较 Virtual DOM Tree 的差异，理论上的时间复杂度高达 O(n^3)，这是一个奇高无比的时间复杂度，很显然选择这种低效的算法是无法满足我们对程序性能的基本要求的。

好在我们实际开发中，很少会出现跨层级的 DOM 变更。通常情况下的 DOM 变更是同级的，因此在现代的各种 Virtual DOM 库都是只比较同级差异，在这种情况下我们的时间复杂度是 O(n)。

snabbdom.js 是社区内主流的 Virtual DOM 实现，vue 2.0 阶段与 snabbdom.js 一样都采用了「双端比较算法」。

而 vue 3.0 会借鉴 inferno.js 的算法进行优化，具体的优化思想可以先参考 [diff 算法原理概述](https://github.com/NervJS/nerv/issues/3)，其中一个核心的思想就是利用 LIS（最长递增子序列）的思想做动态规划，找到最小的移动次数。

>  inferno.js 号称是最快的 react-like 框架（虽然 inferno.js 性能强悍的原因不仅仅是算法，但是其 diff 算法的确是目前最快的）

## React  ⚔️  Vue

两个框架在 组件形式、数据管理、组件数据交互（父子/跨组件）、class 与 style、生命周期、事件处理 (@Click vs onClick) 等很多方面都有一些不同。

### 核心思想

**React**

- react 整体上是**函数式的思想**，将 html 与 css 全都融入 javaScript，组件使用 jsx 语法，All in JS。
- 当组件调用 setState 或 props 变化的时候，组件内部 render 会重新渲染，子组件也会随之重新渲染，可以通过`shouldComponentUpdate`或者`PureComponent`可以避免不必要的重新渲染。

**Vue**

- vue 的整体思想仍然是拥抱经典的 html（结构）+css（表现）+js（行为）的形式，鼓励开发者使用 template 模板，并提供大量指令供开发者使用 (v-on、v-if、v-show、v-for...），因此在开发 vue 应用的时候会有一种在写经典 web 应用的感觉。
- 在处理组件数据方面，Vue3 不仅仅是简单的通过 `Proxy` 来递归侦测数据， 而是通过 `get` 操作来实现内部数据的代理，并且结合 `WeakMap` 来对数据保存，大大的提高响应式数据的性能。

为什么 React 不精确监听数据变化呢？

这是因为 Vue 和 React 设计理念上的区别，Vue 使用的是可变数据，而 React 更强调数据的不可变。所以说没有好坏之分，Vue 更加简单，而 React 构建大型应用的时候更加能够控制细节。

### 关于渲染

在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。

如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用 PureComponent，或是手动实现 shouldComponentUpdate 方法。同时你可能会需要使用不可变的数据结构来使得你的组件更容易被优化。

然而，使用 PureComponent 和 shouldComponentUpdate 时，需要保证该组件的整个子树的渲染输出都是由该组件的 props 所决定的。如果不符合这个情况，那么此类优化就会导致难以察觉的渲染结果不一致。这使得 React 中的组件优化伴随着相当的心智负担。

在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了 shouldComponentUpdate，并且没有上述的子树问题限制。

-  Vue 的这个特点使得开发者不再需要考虑此类优化，从而能够更好地专注于应用本身。当然，对于大型应用来说，基于这一点，还是推荐使用 React，毕竟可以自己决定哪些 props 或者 state 变化才进行 reRender 

### JSX vs Templates

在表层上， 模板的语法不同

- React 是通过 JSX 渲染模板
- 而 Vue 是通过一种拓展的 HTML 语法进行渲染

但其实这只是表面现象，毕竟 React 并不必须依赖 JSX。 在深层上，模板的原理不同，这才是他们的本质区别：

- React 是在组件 JS 代码中，通过原生 JS 实现模板中的常见语法，比如插值，条件，循环等，都是通过 JS 语法实现的
- Vue 是在和组件 JS 代码分离的单独的模板中，通过指令来实现的，比如条件语句就需要 `v-if` 来实现

react 中 render 函数是支持闭包特性的，所以我们 import 的组件在 render 中可以直接调用。但是在 Vue 中，由于模板中使用的数据都必须挂在 `this` 上进行一次中转，所以我们`import` 一个组件完了之后，还需要在 `components`  中再声明下，这样显然是很奇怪但又不得不这样的做法。

在 React 中，所有的组件的渲染功能都依靠 JSX。 使用 JSX 的渲染函数有下面这些优势：

- 你可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。比如你可以使用临时变量、JS 自带的流程控制、以及直接引用当前 JS 作用域中的值等等。
- 开发工具对 JSX 的支持相比于现有可用的其他 Vue 模板还是比较先进的 （比如，linting、类型检查、编辑器的自动完成）。

虽然 Vue 也可以使用 JSX，但基本都使用模版语法，这也带来了一些特有的优势：

- 对于很多习惯了 HTML 的开发者来说，模板比起 JSX 读写起来更自然。这里当然有主观偏好的成分，但如果这种区别会导致开发效率的提升，那么它就有客观的价值存在。
- 基于 HTML 的模板使得将已有的应用逐步迁移到 Vue 更为容易。

使用 Vue 的模版语法开发起来更加便捷快速。可以把组件区分为两类：一类是偏视图表现的 (presentational)，一类则是偏逻辑的 (logical)。我们推荐在前者中使用模板，在后者中使用 JSX 或渲染函数。这两类组件的比例会根据应用类型的不同有所变化，但整体来说我们发现表现类的组件远远多于逻辑类组件。

### HoC 和 mixins

在 Vue 中我们组合不同功能的方式是通过 mixin，而在 React 中我们通过 HoC （高阶组件）。

React 最早也是使用 `mixins` 的，不过后来他们觉得这种方式对组件侵入太强会导致很多问题，就弃用了 mixinx 转而使用 `HoC`

关于 mixin 究竟哪里不好，可以参见这篇文章 Mixins Considered Harmful。

而 Vue 一直是使用 mixin 来实现的。为什么 Vue 不采用 HoC 的方式来实现呢？

高阶组件本质就是高阶函数，React 的组件是一个纯粹的函数，所以高阶函数对 React 来说非常简单。

但是 Vue 就不行了，Vue 中组件是一个被包装的函数，并不简单的就是我们定义组件的时候传入的对象或者函数。比如我们定义的模板怎么被编译的？比如声明的 props 怎么接收到的？这些都是 vue 创建组件实例的时候隐式干的事。由于 vue 默默帮我们做了这么多事，所以我们自己如果直接把组件的声明包装一下，返回一个高阶组件，那么这个被包装的组件就无法正常工作了。

## 路由原理

前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式。

- hash 模式
- history 模式

`www.test.com/##/` 就是 `Hash URL`，当 `##` 后面的哈希值发生变化时，不会向服务器请求数据，可以通过 `hashchange` 事件来监听到 `URL` 的变化，从而进行跳转页面。

`History`模式是 `HTML5` 新推出的功能，比之 `Hash URL` 更加美观。